<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript Moderno (ES6+)</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      color: #333;
      line-height: 1.6;
    }
    .section {
      margin-bottom: 30px;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      background-color: #f9f9f9;
    }
    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 30px;
    }
    h2 {
      color: #3498db;
      border-bottom: 2px solid #3498db;
      padding-bottom: 8px;
      margin-top: 0;
    }
    pre {
      background-color: #f1f1f1;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
    }
    .code-result {
      background-color: #e8f4f8;
      padding: 15px;
      border-radius: 5px;
      margin-top: 10px;
      border-left: 4px solid #3498db;
    }
    .react-comparison {
      background-color: #e8f8f5;
      padding: 15px;
      border-radius: 5px;
      margin-top: 15px;
      border-left: 4px solid #2ecc71;
    }
    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
      font-size: 14px;
    }
    button:hover {
      background-color: #2980b9;
    }
    .warning {
      color: #e74c3c;
    }
    .success {
      color: #27ae60;
    }
    .separator {
      height: 2px;
      background-color: #eee;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>JavaScript Moderno (ES6+): Preparando el Camino hacia React</h1>
  
  <!-- Arrow Functions -->
  <div class="section" id="arrow-functions">
    <h2>Arrow Functions</h2>
    <pre>
// Función tradicional
function sumar(a, b) {
  return a + b;
}

// Arrow Function equivalente
const sumarFlecha = (a, b) => a + b;

// Con un solo parámetro (paréntesis opcionales)
const duplicar = numero => numero * 2;

// Con cuerpo de función
const saludar = (nombre) => {
  const mensaje = `Hola, ${nombre}`;
  console.log(mensaje);
  return mensaje;
};
    </pre>
    <button onclick="probarArrowFunctions()">Probar Arrow Functions</button>
    <div id="arrow-result" class="code-result"></div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> En React, usamos arrow functions para componentes funcionales y para manejar eventos, manteniendo el contexto correcto de <code>this</code>.
      <pre>
// En React
const Button = () => {
  const handleClick = () => {
    console.log('Botón pulsado');
  };
  
  return <button onClick={handleClick}>Click me</button>;
};
      </pre>
    </div>
  </div>

  <!-- Destructuring -->
  <div class="section" id="destructuring">
    <h2>Destructuración</h2>
    <pre>
// Objetos
const usuario = {
  nombre: 'Ana',
  edad: 28,
  ciudad: 'Madrid',
  redes: {
    twitter: '@ana',
    github: 'ana-dev'
  }
};

// Destructuración básica
const { nombre, edad } = usuario;

// Destructuración con alias
const { nombre: nombreUsuario, ciudad: ubicacion } = usuario;

// Destructuración anidada
const { redes: { twitter, github } } = usuario;

// Arrays
const colores = ['rojo', 'verde', 'azul', 'amarillo'];

// Destructuración básica
const [primario, secundario, ...resto] = colores;
    </pre>
    <button onclick="probarDestructuring()">Probar Destructuración</button>
    <div id="destructuring-result" class="code-result"></div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> La destructuración es fundamental en React para extraer props y hooks.
      <pre>
// En React
function UserProfile({ nombre, edad, ciudad }) {
  const [isActive, setIsActive] = useState(false);
  
  return (
    <div>
      <h3>{nombre}</h3>
      <p>{edad} años, {ciudad}</p>
    </div>
  );
}
      </pre>
    </div>
  </div>

  <!-- Spread/Rest Operators -->
  <div class="section" id="spread-rest">
    <h2>Operadores Spread/Rest</h2>
    <pre>
// Spread con arrays
const numeros1 = [1, 2, 3];
const numeros2 = [4, 5, 6];
const combinados = [...numeros1, ...numeros2];

// Clonar arrays
const original = [1, 2, 3];
const copia = [...original];
copia.push(4); // El original no se modifica

// Spread con objetos
const persona = { nombre: 'Carlos', edad: 30 };
const personaConDireccion = {
  ...persona,
  direccion: 'Calle Principal 123'
};

// Rest en parámetros de función
function sumarTodos(...numeros) {
  return numeros.reduce((total, n) => total + n, 0);
}
    </pre>
    <button onclick="probarSpreadRest()">Probar Spread/Rest</button>
    <div id="spread-rest-result" class="code-result"></div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> En React usamos estos operadores para:
      <ul>
        <li>Actualizar el estado de forma inmutable</li>
        <li>Pasar props a componentes hijos</li>
        <li>Combinar props</li>
      </ul>
      <pre>
// En React
function App() {
  const [todo, setTodo] = useState({ text: '', completed: false });
  
  const updateText = (newText) => {
    setTodo({ ...todo, text: newText }); // Actualización inmutable
  };
  
  return <TodoItem {...todo} onChange={updateText} />;
}
      </pre>
    </div>
  </div>

  <!-- Template Literals -->
  <div class="section" id="template-literals">
    <h2>Template Literals</h2>
    <pre>
// Concatenación tradicional
const nombre = 'María';
const edad = 28;
const mensajeTradicional = 'Hola, me llamo ' + nombre + ' y tengo ' + edad + ' años.';

// Con template literals
const mensaje = `Hola, me llamo ${nombre} y tengo ${edad} años.`;

// Con expresiones
const esMayor = `${nombre} ${edad >= 18 ? 'es mayor de edad' : 'es menor de edad'}`;

// Multilínea
const html = `
  &lt;div class="usuario">
    &lt;h3>${nombre}&lt;/h3>
    &lt;p>Edad: ${edad}&lt;/p>
  &lt;/div>
`;
    </pre>
    <button onclick="probarTemplateLiterals()">Probar Template Literals</button>
    <div id="template-literals-result" class="code-result"></div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> Los template literals son similares a la interpolación en JSX:
      <pre>
// En React
function Greeting({ name, age }) {
  return (
    &lt;div>
      &lt;h2>¡Hola, {name}!&lt;/h2>
      &lt;p>Tienes {age} años&lt;/p>
      {age >= 18 ? &lt;p>Eres mayor de edad&lt;/p> : &lt;p>Eres menor de edad&lt;/p>}
    &lt;/div>
  );
}
      </pre>
    </div>
  </div>

  <!-- Modules -->
  <div class="section" id="modules">
    <h2>Módulos ES6</h2>
    <pre>
// En matematicas.js
export const PI = 3.14159;
export function sumar(a, b) { return a + b; }
const restar = (a, b) => a - b;
export { restar };
export default class Calculadora {
  multiplicar(a, b) { return a * b; }
}

// En app.js
import Calculadora, { PI, sumar, restar as resta } from './matematicas.js';
import * as utils from './utilidades.js';

const calc = new Calculadora();
console.log(sumar(5, 3));         // 8
console.log(calc.multiplicar(4, 2)); // 8
console.log(utils.formatearFecha(new Date())); // Ej: "2023-10-30"
    </pre>
    <div class="code-result">
      <p>Los módulos ES6 permiten organizar el código en archivos separados.</p>
      <p>Funcionan en navegadores modernos con <code>&lt;script type="module"&gt;</code> o mediante empaquetadores como Webpack o Vite.</p>
    </div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> Los módulos ES6 son cruciales en React para importar componentes, hooks y utilidades:
      <pre>
// En React
import React, { useState, useEffect } from 'react';
import Header from './components/Header';
import { fetchData } from './api';

export default function App() {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    fetchData().then(setData);
  }, []);
  
  return (
    &lt;div>
      &lt;Header />
      {/* Resto del componente */}
    &lt;/div>
  );
}
      </pre>
    </div>
  </div>

  <!-- Clases -->
  <div class="section" id="classes">
    <h2>Clases</h2>
    <pre>
// Definición de clase
class Persona {
  constructor(nombre, edad) {
    this.nombre = nombre;
    this.edad = edad;
  }
  
  saludar() {
    return `Hola, soy ${this.nombre} y tengo ${this.edad} años.`;
  }
  
  static crear(nombreCompleto) {
    const [nombre, apellido] = nombreCompleto.split(' ');
    return new Persona(nombre, 25);
  }
}

// Herencia
class Empleado extends Persona {
  constructor(nombre, edad, puesto) {
    super(nombre, edad); // Llamada al constructor padre
    this.puesto = puesto;
  }
  
  saludar() {
    return `${super.saludar()} Trabajo como ${this.puesto}.`;
  }
}
    </pre>
    <button onclick="probarClases()">Probar Clases</button>
    <div id="classes-result" class="code-result"></div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> Antes de los hooks, React usaba principalmente componentes de clase:
      <pre>
// En React (componente de clase)
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.increment = this.increment.bind(this);
  }
  
  increment() {
    this.setState({ count: this.state.count + 1 });
  }
  
  render() {
    return (
      &lt;div>
        &lt;p>Contador: {this.state.count}&lt;/p>
        &lt;button onClick={this.increment}>Incrementar&lt;/button>
      &lt;/div>
    );
  }
}

// Con hooks (funcional):
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div>
      &lt;p>Contador: {count}&lt;/p>
      &lt;button onClick={() => setCount(count + 1)}>Incrementar&lt;/button>
    &lt;/div>
  );
}
      </pre>
    </div>
  </div>

  <!-- Fetch API y Promises -->
  <div class="section" id="fetch-promises">
    <h2>Fetch API y Promesas</h2>
    <pre>
// Promesas básicas
const promesa = new Promise((resolve, reject) => {
  setTimeout(() => {
    const exito = true;
    if (exito) {
      resolve('Operación completada');
    } else {
      reject('Error en la operación');
    }
  }, 1000);
});

promesa
  .then(mensaje => console.log(mensaje))
  .catch(error => console.error(error));

// Fetch API
fetch('https://jsonplaceholder.typicode.com/users')
  .then(response => {
    if (!response.ok) {
      throw new Error('Error en la respuesta');
    }
    return response.json();
  })
  .then(data => console.log('Usuarios:', data))
  .catch(error => console.error('Error:', error));

// Async/Await (azúcar sintáctico sobre promesas)
async function obtenerDatos() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    if (!response.ok) throw new Error('Error en la respuesta');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error:', error);
    return [];
  }
}
    </pre>
    <button onclick="probarFetchPromises()">Probar Fetch y Promesas</button>
    <div id="fetch-promises-result" class="code-result"></div>
    <div class="react-comparison">
      <strong>Comparación con React:</strong> Las promesas son fundamentales para gestionar operaciones asíncronas en React:
      <pre>
// En React con useEffect y async/await
function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchUsers() {
      try {
        setLoading(true);
        const response = await fetch('https://api.example.com/users');
        if (!response.ok) throw new Error('Error al cargar usuarios');
        const data = await response.json();
        setUsers(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    fetchUsers();
  }, []);

  if (loading) return &lt;p>Cargando...&lt;/p>;
  if (error) return &lt;p>Error: {error}&lt;/p>;
  
  return (
    &lt;ul>
      {users.map(user => (
        &lt;li key={user.id}>{user.name}&lt;/li>
      ))}
    &lt;/ul>
  );
}
      </pre>
    </div>
  </div>
  
  <!-- Todo List Example -->
  <div class="section" id="todo-app">
    <h2>Aplicación Práctica: Lista de Tareas</h2>
    <p>Esta aplicación implementa una lista de tareas utilizando JavaScript moderno. Es similar a lo que veremos en React, pero sin sus ventajas.</p>
    
    <div id="todo-container">
      <!-- La aplicación se renderizará aquí -->
    </div>
    
    <div class="separator"></div>
    
    <div class="react-comparison">
      <strong>Limitaciones de este enfoque vs. React:</strong>
      <ul>
        <li><strong>Re-renderizado ineficiente:</strong> Actualizamos todo el DOM en cada cambio, mientras que React solo actualiza lo que cambia gracias a su Virtual DOM.</li>
        <li><strong>Gestión de estado manual:</strong> React proporciona mecanismos como useState y useReducer para manejar el estado de forma más predecible.</li>
        <li><strong>Sin componentización:</strong> En React, dividiríamos esto en componentes reutilizables (TodoList, TodoItem, AddTodoForm, etc.).</li>
        <li><strong>Event listeners redundantes:</strong> Debemos agregar los mismos listeners cada vez que renderizamos, mientras que React maneja esto automáticamente.</li>
      </ul>
    </div>
  </div>

  <script>
    // Arrow Functions
    function probarArrowFunctions() {
      const resultDiv = document.getElementById('arrow-result');
      
      // Función tradicional
      function sumar(a, b) {
        return a + b;
      }
      
      // Arrow Function
      const sumarFlecha = (a, b) => a + b;
      
      // Con un solo parámetro
      const duplicar = numero => numero * 2;
      
      // Con cuerpo de función
      const saludar = (nombre) => {
        const mensaje = `Hola, ${nombre}`;
        return mensaje;
      };
      
      // Ejemplo de this
      function DemoThis() {
        this.valor = 42;
        
        // Con función tradicional
        setTimeout(function() {
          this.otroValor = "¡this no es el esperado!";
          resultDiv.innerHTML += `<p class="warning">Función tradicional - this.valor: ${this.valor}</p>`;
        }, 100);
        
        // Con arrow function
        setTimeout(() => {
          resultDiv.innerHTML += `<p class="success">Arrow function - this.valor: ${this.valor}</p>`;
        }, 200);
      }
      
      resultDiv.innerHTML = `
        <p>sumar(5, 3): ${sumar(5, 3)}</p>
        <p>sumarFlecha(5, 3): ${sumarFlecha(5, 3)}</p>
        <p>duplicar(7): ${duplicar(7)}</p>
        <p>saludar('María'): ${saludar('María')}</p>
      `;
      
      new DemoThis();
    }
    
    // Destructuring
    function probarDestructuring() {
      const resultDiv = document.getElementById('destructuring-result');
      
      const usuario = {
        nombre: 'Ana',
        edad: 28,
        ciudad: 'Madrid',
        redes: {
          twitter: '@ana',
          github: 'ana-dev'
        }
      };
      
      // Destructuración básica
      const { nombre, edad } = usuario;
      
      // Destructuración con alias
      const { nombre: nombreUsuario, ciudad: ubicacion } = usuario;
      
      // Destructuración anidada
      const { redes: { twitter, github } } = usuario;
      
      // Arrays
      const colores = ['rojo', 'verde', 'azul', 'amarillo'];
      
      // Destructuración de arrays
      const [primario, secundario, ...resto] = colores;
      
      // Parámetros de función con destructuración
      function mostrarUsuario({ nombre, edad, ciudad = 'Desconocida' }) {
        return `${nombre}, ${edad} años, ${ciudad}`;
      }
      
      resultDiv.innerHTML = `
        <p>nombre, edad: ${nombre}, ${edad}</p>
        <p>nombreUsuario, ubicacion: ${nombreUsuario}, ${ubicacion}</p>
        <p>twitter, github: ${twitter}, ${github}</p>
        <p>primario, secundario: ${primario}, ${secundario}</p>
        <p>resto: [${resto}]</p>
        <p>mostrarUsuario(usuario): ${mostrarUsuario(usuario)}</p>
        <p>mostrarUsuario({nombre: 'Pedro', edad: 30}): ${mostrarUsuario({nombre: 'Pedro', edad: 30})}</p>
      `;
    }
    
    // Spread/Rest
    function probarSpreadRest() {
      const resultDiv = document.getElementById('spread-rest-result');
      
      // Spread con arrays
      const numeros1 = [1, 2, 3];
      const numeros2 = [4, 5, 6];
      const combinados = [...numeros1, ...numeros2];
      
      // Clonar arrays
      const original = [1, 2, 3];
      const copia = [...original];
      copia.push(4);
      
      // Spread con objetos
      const persona = { nombre: 'Carlos', edad: 30 };
      const personaConDireccion = {
        ...persona,
        direccion: 'Calle Principal 123'
      };
      
      // Sobrescribir propiedades
      const personaActualizada = {
        ...persona,
        edad: 31, // Sobrescribe la edad
        profesion: 'Desarrollador' // Añade nueva propiedad
      };
      
      // Rest en parámetros de función
      function sumarTodos(...numeros) {
        return numeros.reduce((total, n) => total + n, 0);
      }
      
      resultDiv.innerHTML = `
        <p>combinados: [${combinados}]</p>
        <p>original después de modificar copia: [${original}]</p>
        <p>copia modificada: [${copia}]</p>
        <p>personaConDireccion: ${JSON.stringify(personaConDireccion)}</p>
        <p>personaActualizada: ${JSON.stringify(personaActualizada)}</p>
        <p>sumarTodos(1, 2, 3, 4, 5): ${sumarTodos(1, 2, 3, 4, 5)}</p>
      `;
    }
    
    // Template Literals
    function probarTemplateLiterals() {
      const resultDiv = document.getElementById('template-literals-result');
      
      const nombre = 'María';
      const edad = 28;
      
      // Concatenación tradicional
      const mensajeTradicional = 'Hola, me llamo ' + nombre + ' y tengo ' + edad + ' años.';
      
      // Con template literals
      const mensaje = `Hola, me llamo ${nombre} y tengo ${edad} años.`;
      
      // Con expresiones
      const esMayor = `${nombre} ${edad >= 18 ? 'es mayor de edad' : 'es menor de edad'}`;
      
      // Multilínea
      const html = `
        <div class="usuario">
          <h3>${nombre}</h3>
          <p>Edad: ${edad}</p>
        </div>
      `;
      
      resultDiv.innerHTML = `
        <p><strong>Concatenación tradicional:</strong> ${mensajeTradicional}</p>
        <p><strong>Template literal:</strong> ${mensaje}</p>
        <p><strong>Con expresión:</strong> ${esMayor}</p>
        <p><strong>HTML generado:</strong></p>
        ${html}
      `;
    }
    
    // Clases
    function probarClases() {
      const resultDiv = document.getElementById('classes-result');
      
      // Definición de clase
      class Persona {
        constructor(nombre, edad) {
          this.nombre = nombre;
          this.edad = edad;
        }
        
        saludar() {
          return `Hola, soy ${this.nombre} y tengo ${this.edad} años.`;
        }
        
        static crear(nombreCompleto) {
          const [nombre] = nombreCompleto.split(' ');
          return new Persona(nombre, 25);
        }
      }
      
      // Herencia
      class Empleado extends Persona {
        constructor(nombre, edad, puesto) {
          super(nombre, edad);
          this.puesto = puesto;
        }
        
        saludar() {
          return `${super.saludar()} Trabajo como ${this.puesto}.`;
        }
        
        trabajar() {
          return `${this.nombre} está trabajando como ${this.puesto}.`;
        }
      }
      
      const ana = new Persona('Ana', 28);
      const carlos = Persona.crear('Carlos Rodríguez');
      const juan = new Empleado('Juan', 35, 'desarrollador');
      
      resultDiv.innerHTML = `
        <p>ana.saludar(): ${ana.saludar()}</p>
        <p>carlos.saludar(): ${carlos.saludar()}</p>
        <p>juan.saludar(): ${juan.saludar()}</p>
        <p>juan.trabajar(): ${juan.trabajar()}</p>
        <p>juan instanceof Empleado: ${juan instanceof Empleado}</p>
        <p>juan instanceof Persona: ${juan instanceof Persona}</p>
      `;
    }
    
    // Fetch y Promesas
    function probarFetchPromises() {
      const resultDiv = document.getElementById('fetch-promises-result');
      resultDiv.innerHTML = '<p>Cargando datos...</p>';
      
      // Promesa simple para mostrar
      const promesaSimple = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('¡Promesa resuelta después de 2 segundos!');
        }, 2000);
      });
      
      promesaSimple.then(mensaje => {
        resultDiv.innerHTML += `<p>${mensaje}</p>`;
      });
      
      // Fetch API
      fetch('https://jsonplaceholder.typicode.com/users')
        .then(response => {
          if (!response.ok) {
            throw new Error('Error en la respuesta');
          }
          return response.json();
        })
        .then(data => {
          // Mostrar solo 3 usuarios para simplificar
          const usuarios = data.slice(0, 3);
          resultDiv.innerHTML += `
            <p>Datos de usuarios obtenidos correctamente:</p>
            <ul>
              ${usuarios.map(usuario => `<li>${usuario.name} (${usuario.email})</li>`).join('')}
            </ul>
            <p><strong>Total de usuarios:</strong> ${data.length}</p>
          `;
        })
        .catch(error => {
          resultDiv.innerHTML += `<p class="warning">Error: ${error.message}</p>`;
        });
      
      // Ejemplo de async/await
      async function ejemploAsync() {
        try {
          resultDiv.innerHTML += '<p>Iniciando petición con async/await...</p>';
          
          const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
          if (!response.ok) throw new Error('Error en la respuesta');
          
          const tarea = await response.json();
          
          resultDiv.innerHTML += `
            <p>Tarea obtenida con async/await:</p>
            <p><strong>Título:</strong> ${tarea.title}</p>
            <p><strong>Completada:</strong> ${tarea.completed ? 'Sí' : 'No'}</p>
          `;
        } catch (error) {
          resultDiv.innerHTML += `<p class="warning">Error async/await: ${error.message}</p>`;
        }
      }
      
      ejemploAsync();
    }
    
    // Todo App
    class TodoApp {
      constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.tareas = [
          { id: 1, texto: 'Aprender JavaScript moderno', completada: true },
          { id: 2, texto: 'Practicar con ejemplos', completada: false },
          { id: 3, texto: 'Estudiar React', completada: false }
        ];
        
        this.render();
      }
      
      agregarTarea(texto) {
        const nuevaTarea = {
          id: Date.now(),
          texto,
          completada: false
        };
        
        this.tareas = [...this.tareas, nuevaTarea];
        this.render();
      }
      
      eliminarTarea(id) {
        this.tareas = this.tareas.filter(tarea => tarea.id !== id);
        this.render();
      }
      
      toggleCompletada(id) {
        this.tareas = this.tareas.map(tarea => 
          tarea.id === id 
            ? { ...tarea, completada: !tarea.completada } 
            : tarea
        );
        this.render();
      }
      
      render() {
        this.element.innerHTML = `
          <div class="todo-app">
            <h3>Lista de Tareas</h3>
            
            <div style="display: flex; margin-bottom: 15px;">
              <input type="text" id="nuevaTarea" placeholder="Nueva tarea..." 
                     style="flex-grow: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px 0 0 4px;">
              <button id="agregarBtn" 
                      style="padding: 8px 15px; background-color: #3498db; color: white; border: none; border-radius: 0 4px 4px 0; cursor: pointer;">
                Añadir
              </button>
            </div>
            
            <ul style="list-style: none; padding: 0;">
              ${this.tareas.map(tarea => `
                <li style="display: flex; align-items: center; padding: 10px; background-color: white; 
                           margin-bottom: 8px; border-radius: 4px; border-left: 3px solid ${tarea.completada ? '#27ae60' : '#3498db'};">
                  <input type="checkbox" data-id="${tarea.id}" ${tarea.completada ? 'checked' : ''}>
                  <span style="margin: 0 10px; flex-grow: 1; ${tarea.completada ? 'text-decoration: line-through; color: #7f8c8d;' : ''}">
                    ${tarea.texto}
                  </span>
                  <button data-id="${tarea.id}" class="delete-btn" 
                          style="padding: 5px 10px; background-color: #e74c3c; color: white; border: none; 
                                 border-radius: 4px; cursor: pointer;">
                    Eliminar
                  </button>
                </li>
              `).join('')}
            </ul>
            
            <p style="margin-top: 15px; font-size: 14px; color: #7f8c8d;">
              ${this.tareas.filter(t => t.completada).length} de ${this.tareas.length} tareas completadas
            </p>
          </div>
        `;
        
        // Event listeners
        document.getElementById('agregarBtn').addEventListener('click', () => {
          const input = document.getElementById('nuevaTarea');
          const texto = input.value.trim();
          
          if (texto) {
            this.agregarTarea(texto);
            input.value = '';
          }
        });
        
        document.querySelectorAll('.delete-btn').forEach(btn => {
          btn.addEventListener('click', e => {
            const id = parseInt(e.target.dataset.id);
            this.eliminarTarea(id);
          });
        });
        
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          checkbox.addEventListener('change', e => {
            const id = parseInt(e.target.dataset.id);
            this.toggleCompletada(id);
          });
        });
      }
    }
    
    // Inicializar la aplicación
    document.addEventListener('DOMContentLoaded', () => {
      new TodoApp('todo-container');
    });
  </script>
</body>
</html> 